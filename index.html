<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Block World</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }

        #instructions h3 {
            margin: 0 0 10px 0;
            color: #00ff00;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            z-index: 100;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            left: 50%;
            width: 2px;
            height: 20px;
            margin-left: -1px;
        }

        #crosshair::after {
            top: 50%;
            width: 20px;
            height: 2px;
            margin-top: -1px;
        }

        /* Virtual Joystick Styles */
        #joystick-container {
            position: absolute;
            bottom: 80px;
            right: 80px;
            width: 120px;
            height: 120px;
            z-index: 100;
        }

        #joystick-base {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }

        #joystick-knob {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.9);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.1s ease;
        }

        #movement-joystick {
            position: absolute;
            bottom: 80px;
            left: 80px;
            width: 120px;
            height: 120px;
            z-index: 100;
        }

        @media (max-width: 768px) {
            #instructions {
                font-size: 12px;
                padding: 10px;
            }
            
            #joystick-container,
            #movement-joystick {
                width: 100px;
                height: 100px;
                bottom: 30px;
            }
            
            #joystick-container {
                right: 30px;
            }
            
            #movement-joystick {
                left: 30px;
            }
            
            #joystick-base {
                width: 100px;
                height: 100px;
            }
            
            #joystick-knob {
                width: 40px;
                height: 40px;
            }
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h3>ðŸŽ® 3D Block World</h3>
        <p><strong>WASD</strong> - Move around</p>
        <p><strong>Mouse/Right Joystick</strong> - Look around</p>
        <p><strong>Left Joystick</strong> - Move (Mobile)</p>
        <p><strong>Space</strong> - Jump</p>
        <p><strong>Click</strong> - Place/Remove blocks</p>
    </div>

    <div id="crosshair"></div>

    <!-- Virtual Joysticks -->
    <div id="movement-joystick">
        <div id="move-joystick-base" style="width: 120px; height: 120px; border-radius: 50%; background: rgba(255, 255, 255, 0.1); border: 3px solid rgba(255, 255, 255, 0.3); position: relative;">
            <div id="move-joystick-knob" style="width: 50px; height: 50px; border-radius: 50%; background: rgba(255, 255, 255, 0.8); border: 2px solid rgba(255, 255, 255, 0.9); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: pointer; transition: all 0.1s ease;"></div>
        </div>
    </div>

    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-knob"></div>
        </div>
    </div>

    <!-- Action Buttons -->
    <button id="break-button" style="position: absolute; bottom: 220px; right: 80px; width: 60px; height: 60px; border-radius: 50%; background: rgba(255, 0, 0, 0.8); border: 3px solid rgba(255, 255, 255, 0.9); color: white; font-weight: bold; font-size: 24px; cursor: pointer; z-index: 100; transition: all 0.2s ease;">âŠ—</button>
    
    <button id="place-button" style="position: absolute; bottom: 220px; left: 80px; width: 60px; height: 60px; border-radius: 50%; background: rgba(0, 200, 0, 0.8); border: 3px solid rgba(255, 255, 255, 0.9); color: white; font-weight: bold; font-size: 28px; cursor: pointer; z-index: 100; transition: all 0.2s ease;">+</button>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // 3D Game variables
        let scene, camera, renderer, raycaster;
        let player = { x: 5, y: 2, z: 5 };
        let velocity = { x: 0, y: 0, z: 0 };
        let blocks = [];
        let keys = {};
        let mouse = new THREE.Vector2();
        let isPointerLocked = false;

        // Joystick variables
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickOffset = { x: 0, y: 0 };
        let moveJoystickActive = false;
        let moveJoystickCenter = { x: 0, y: 0 };
        let moveJoystickOffset = { x: 0, y: 0 };

        // Initialize 3D world
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(player.x, player.y, player.z);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create raycaster for block placement
            raycaster = new THREE.Raycaster();

            // Build initial world
            createWorld();
            setupControls();
            animate();
        }

        // Create the block world
        function createWorld() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const materials = [
                new THREE.MeshLambertMaterial({ color: 0x00ff00 }), // Green
                new THREE.MeshLambertMaterial({ color: 0x8B4513 }), // Brown
                new THREE.MeshLambertMaterial({ color: 0x808080 }), // Gray
            ];

            // Create ground platform (10x10 grid)
            for (let x = 0; x < 15; x++) {
                for (let z = 0; z < 15; z++) {
                    const block = new THREE.Mesh(geometry, materials[0]);
                    block.position.set(x, 0, z);
                    block.castShadow = true;
                    block.receiveShadow = true;
                    scene.add(block);
                    blocks.push({ mesh: block, x: x, y: 0, z: z });
                }
            }

            // Add some random blocks for variety
            for (let i = 0; i < 20; i++) {
                const x = Math.floor(Math.random() * 15);
                const z = Math.floor(Math.random() * 15);
                const y = Math.floor(Math.random() * 3) + 1;
                const material = materials[Math.floor(Math.random() * materials.length)];
                
                const block = new THREE.Mesh(geometry, material);
                block.position.set(x, y, z);
                block.castShadow = true;
                block.receiveShadow = true;
                scene.add(block);
                blocks.push({ mesh: block, x: x, y: y, z: z });
            }
        }

        // Setup controls
        function setupControls() {
            // Keyboard events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse events
            document.addEventListener('click', requestPointerLock);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Setup virtual joysticks
            setupJoysticks();

            // Setup action buttons
            setupActionButtons();
        }

        function setupJoysticks() {
            const lookJoystick = document.getElementById('joystick-knob');
            const lookJoystickBase = document.getElementById('joystick-base');
            const moveJoystick = document.getElementById('move-joystick-knob');
            const moveJoystickBase = document.getElementById('move-joystick-base');

            // Look joystick (right side)
            lookJoystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                const rect = lookJoystickBase.getBoundingClientRect();
                joystickCenter.x = rect.left + rect.width / 2;
                joystickCenter.y = rect.top + rect.height / 2;
            });

            lookJoystick.addEventListener('mousedown', (e) => {
                e.preventDefault();
                joystickActive = true;
                const rect = lookJoystickBase.getBoundingClientRect();
                joystickCenter.x = rect.left + rect.width / 2;
                joystickCenter.y = rect.top + rect.height / 2;
            });

            // Movement joystick (left side)
            moveJoystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                moveJoystickActive = true;
                const rect = moveJoystickBase.getBoundingClientRect();
                moveJoystickCenter.x = rect.left + rect.width / 2;
                moveJoystickCenter.y = rect.top + rect.height / 2;
            });

            moveJoystick.addEventListener('mousedown', (e) => {
                e.preventDefault();
                moveJoystickActive = true;
                const rect = moveJoystickBase.getBoundingClientRect();
                moveJoystickCenter.x = rect.left + rect.width / 2;
                moveJoystickCenter.y = rect.top + rect.height / 2;
            });

            // Global touch/mouse move events
            document.addEventListener('touchmove', handleJoystickMove);
            document.addEventListener('mousemove', handleJoystickMove);
            
            // Global touch/mouse end events
            document.addEventListener('touchend', () => {
                joystickActive = false;
                moveJoystickActive = false;
                resetJoysticks();
            });
            
            document.addEventListener('mouseup', () => {
                joystickActive = false;
                moveJoystickActive = false;
                resetJoysticks();
            });
        }

        function handleJoystickMove(e) {
            if (joystickActive) {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                joystickOffset.x = clientX - joystickCenter.x;
                joystickOffset.y = clientY - joystickCenter.y;
                
                // Limit joystick range
                const maxDistance = 40;
                const distance = Math.sqrt(joystickOffset.x ** 2 + joystickOffset.y ** 2);
                if (distance > maxDistance) {
                    joystickOffset.x = (joystickOffset.x / distance) * maxDistance;
                    joystickOffset.y = (joystickOffset.y / distance) * maxDistance;
                }
                
                // Update joystick knob position
                const knob = document.getElementById('joystick-knob');
                knob.style.transform = `translate(calc(-50% + ${joystickOffset.x}px), calc(-50% + ${joystickOffset.y}px))`;
                
                // Apply camera rotation
                if (!isPointerLocked) {
                    const sensitivity = 0.01;
                    camera.rotation.y -= joystickOffset.x * sensitivity;
                    camera.rotation.x -= joystickOffset.y * sensitivity;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                }
            }

            if (moveJoystickActive) {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                moveJoystickOffset.x = clientX - moveJoystickCenter.x;
                moveJoystickOffset.y = clientY - moveJoystickCenter.y;
                
                // Limit joystick range
                const maxDistance = 40;
                const distance = Math.sqrt(moveJoystickOffset.x ** 2 + moveJoystickOffset.y ** 2);
                if (distance > maxDistance) {
                    moveJoystickOffset.x = (moveJoystickOffset.x / distance) * maxDistance;
                    moveJoystickOffset.y = (moveJoystickOffset.y / distance) * maxDistance;
                }
                
                // Update joystick knob position
                const knob = document.getElementById('move-joystick-knob');
                knob.style.transform = `translate(calc(-50% + ${moveJoystickOffset.x}px), calc(-50% + ${moveJoystickOffset.y}px))`;
            }
        }

        function resetJoysticks() {
            joystickOffset.x = 0;
            joystickOffset.y = 0;
            moveJoystickOffset.x = 0;
            moveJoystickOffset.y = 0;
            
            document.getElementById('joystick-knob').style.transform = 'translate(-50%, -50%)';
            document.getElementById('move-joystick-knob').style.transform = 'translate(-50%, -50%)';
        }

        // Setup action buttons
        function setupActionButtons() {
            const breakButton = document.getElementById('break-button');
            const placeButton = document.getElementById('place-button');

            breakButton.addEventListener('click', () => {
                breakBlock();
                // Visual feedback
                breakButton.style.transform = 'scale(0.8)';
                setTimeout(() => breakButton.style.transform = 'scale(1)', 100);
            });

            breakButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                breakBlock();
                breakButton.style.transform = 'scale(0.8)';
                setTimeout(() => breakButton.style.transform = 'scale(1)', 100);
            });

            placeButton.addEventListener('click', () => {
                placeBlock();
                // Visual feedback
                placeButton.style.transform = 'scale(0.8)';
                setTimeout(() => placeButton.style.transform = 'scale(1)', 100);
            });

            placeButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                placeBlock();
                placeButton.style.transform = 'scale(0.8)';
                setTimeout(() => placeButton.style.transform = 'scale(1)', 100);
            });
        }

        function breakBlock() {
            // Cast ray from center of screen
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                for (let intersect of intersects) {
                    const blockPos = intersect.object.position;
                    // Don't remove ground blocks (y == 0)
                    if (blockPos.y > 0 && intersect.object.geometry && intersect.object.geometry.type === 'BoxGeometry') {
                        scene.remove(intersect.object);
                        blocks = blocks.filter(b => b.mesh !== intersect.object);
                        break;
                    }
                }
            }
        }

        function placeBlock() {
            // Cast ray from center of screen
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                for (let intersect of intersects) {
                    // Only place on blocks, not lights
                    if (intersect.object.geometry && intersect.object.geometry.type === 'BoxGeometry') {
                        const blockPos = intersect.object.position;
                        const normal = intersect.face.normal;
                        const newPos = blockPos.clone().add(normal);
                        
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: Math.random() * 0xffffff 
                        });
                        const newBlock = new THREE.Mesh(geometry, material);
                        newBlock.position.copy(newPos);
                        newBlock.castShadow = true;
                        newBlock.receiveShadow = true;
                        scene.add(newBlock);
                        blocks.push({ mesh: newBlock, x: newPos.x, y: newPos.y, z: newPos.z });
                        break;
                    }
                }
            }
        }

        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function requestPointerLock() {
            renderer.domElement.requestPointerLock();
        }

        function onPointerLockChange() {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        }

        function onMouseMove(event) {
            if (!isPointerLocked) return;

            const sensitivity = 0.002;
            camera.rotation.y -= event.movementX * sensitivity;
            camera.rotation.x -= event.movementY * sensitivity;
            camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        }

        function onMouseDown(event) {
            if (!isPointerLocked) return;

            // Cast ray to find blocks
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const blockPos = intersect.object.position;

                if (event.button === 0) { // Left click - remove block
                    if (blockPos.y > 0) { // Don't remove ground blocks
                        scene.remove(intersect.object);
                        blocks = blocks.filter(b => b.mesh !== intersect.object);
                    }
                } else if (event.button === 2) { // Right click - add block
                    const normal = intersect.face.normal;
                    const newPos = blockPos.clone().add(normal);
                    
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: Math.random() * 0xffffff 
                    });
                    const newBlock = new THREE.Mesh(geometry, material);
                    newBlock.position.copy(newPos);
                    newBlock.castShadow = true;
                    newBlock.receiveShadow = true;
                    scene.add(newBlock);
                    blocks.push({ mesh: newBlock, x: newPos.x, y: newPos.y, z: newPos.z });
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Update player movement
        function updatePlayer() {
            const speed = 0.1;
            const jumpForce = 0.15;

            // Movement based on camera direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));

            // Keyboard movement
            if (keys['KeyW']) {
                velocity.x += direction.x * speed;
                velocity.z += direction.z * speed;
            }
            if (keys['KeyS']) {
                velocity.x -= direction.x * speed;
                velocity.z -= direction.z * speed;
            }
            if (keys['KeyA']) {
                velocity.x -= right.x * speed;
                velocity.z -= right.z * speed;
            }
            if (keys['KeyD']) {
                velocity.x += right.x * speed;
                velocity.z += right.z * speed;
            }

            // Joystick movement (left joystick)
            if (moveJoystickActive) {
                const joystickSpeed = 0.002;
                // Forward/backward movement
                velocity.x -= direction.x * moveJoystickOffset.y * joystickSpeed;
                velocity.z -= direction.z * moveJoystickOffset.y * joystickSpeed;
                // Left/right strafe
                velocity.x += right.x * moveJoystickOffset.x * joystickSpeed;
                velocity.z += right.z * moveJoystickOffset.x * joystickSpeed;
            }

            if (keys['Space'] && player.y <= 2.1) {
                velocity.y = jumpForce;
            }

            // Apply gravity
            velocity.y -= 0.01;

            // Save old position for collision detection
            const oldX = player.x;
            const oldY = player.y;
            const oldZ = player.z;

            // Update player position
            player.x += velocity.x;
            player.y += velocity.y;
            player.z += velocity.z;

            // Check collision with blocks
            const playerSize = 0.4; // Player collision radius
            const playerHeight = 1.8; // Player height
            let collided = false;

            for (let block of blocks) {
                const bx = block.x;
                const by = block.y;
                const bz = block.z;

                // Check if player overlaps with block (simple box collision)
                if (player.x + playerSize > bx - 0.5 && player.x - playerSize < bx + 0.5 &&
                    player.y + playerHeight > by - 0.5 && player.y - 0.1 < by + 0.5 &&
                    player.z + playerSize > bz - 0.5 && player.z - playerSize < bz + 0.5) {
                    
                    // Collision detected - revert movement
                    collided = true;

                    // Check which axis caused the collision and revert only that
                    const testX = oldX;
                    const testY = player.y;
                    const testZ = player.z;
                    
                    // Test if X movement caused collision
                    if (testX + playerSize > bx - 0.5 && testX - playerSize < bx + 0.5 &&
                        testY + playerHeight > by - 0.5 && testY - 0.1 < by + 0.5 &&
                        testZ + playerSize > bz - 0.5 && testZ - playerSize < bz + 0.5) {
                        // X is fine, try reverting Y or Z
                        player.x = oldX;
                        velocity.x = 0;
                    }

                    // Test Y separately (for ground and ceiling)
                    const testY2 = oldY;
                    if (player.x + playerSize > bx - 0.5 && player.x - playerSize < bx + 0.5 &&
                        testY2 + playerHeight > by - 0.5 && testY2 - 0.1 < by + 0.5 &&
                        player.z + playerSize > bz - 0.5 && player.z - playerSize < bz + 0.5) {
                        player.y = oldY;
                        velocity.y = 0;
                        
                        // If landing on top of block, set player on top
                        if (velocity.y < 0 && player.y < by + 0.5) {
                            player.y = by + 1;
                        }
                    }

                    // Test Z
                    const testZ2 = oldZ;
                    if (player.x + playerSize > bx - 0.5 && player.x - playerSize < bx + 0.5 &&
                        player.y + playerHeight > by - 0.5 && player.y - 0.1 < by + 0.5 &&
                        testZ2 + playerSize > bz - 0.5 && testZ2 - playerSize < bz + 0.5) {
                        player.z = oldZ;
                        velocity.z = 0;
                    }
                }
            }

            // Ground collision (if not standing on a block)
            if (player.y < 1) {
                player.y = 1;
                velocity.y = 0;
            }

            // Keep player in bounds
            player.x = Math.max(0, Math.min(14, player.x));
            player.z = Math.max(0, Math.min(14, player.z));

            // Apply friction
            velocity.x *= 0.8;
            velocity.z *= 0.8;

            // Update camera position
            camera.position.set(player.x, player.y, player.z);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            renderer.render(scene, camera);
        }

        // Prevent right-click menu
        document.addEventListener('contextmenu', e => e.preventDefault());

        // Start the game
        init();
    </script>
</body>
</html>